# @markup markdown
# @title Beginner tutorial: writing a service from scratch
# @author Beno√Æt Faucon

# Introduction #

This guide will guide you step by step on writing a (rather silly but instructive nonetheless) service. The agent we will develop on this guide performs the common task of querying an external web API and sending back the results to the device.

There are two parts in this service: an agent, written in Ruby, that will run on a MDI server, and a software component, written in Java, that will run on the MDI device.

This guide will focus on the agent part, but will also explain how to write the component.

It assumes no previous knowledge of any MDI product or technology. However, it does assume some familiarity with the Ruby programming language (for developping the agent which will run on the MDI servers). If you don't know Ruby yet, there is a lot of good tutorials on the Net about this language. For instance, you can try the Ruby Primer at http://rubymonk.com.

Some very basic knowledge of HTTP would also be useful.

If you also want to follow the part where we develop the device component, then you also need some notions about the Java programming language.

# What you will learn #

* Good practices when developping agents
* How to use the SDK GUI (inside your browser)
* How to write tests for your agent
* The API the SDK gives you

# Our goal #

Because long road travels are boring, we want to give users a "Give me a FML" application to entertain them. On the device, this application will display a text area and a button. When the user clicks on the button, the application will display three FML facts in the text area.

What is a FML fact? They come from this website: http://www.fmylife.com/. I told you this service would be silly.

As we expect this application to be highly successful, we can not afford to query FML each time a user press the button, because that would result in far too many requests to the FML website, and they would not be happy with that. Instead, we will need to cache the data (i.e make only one request per day, and store the result of this request in a "cache") coming from this website.

When a user click on the button, the application will query our agent for a list of three FML facts. Our agent will retrieve three random facts from its cache and send them to the agent. The agent will update its cache every day, so we will only make one request to FML per day.

# Getting started #

First, you need your MDI virtual machine (VM) up and running. Because you are currently reading this page, I assume it is already done. Remember that you have a `README` file in the root folder of your VM should you ever forget how to start it.

The VM runs two local servers:

- on <http://0.0.0.0:5000> (admin server), you will find a graphical interface that allows you to easily
  - manage your agents
  - acces stats about the running agents
  - access the logs generated by your agent or the VM
  - run your automated tests and see their results (with a nice export feature)
- on http://0.0.0.0:5001 runs the SDK agents server. This server simulates the real cloud environment of MDI and is responsible for running your agents and communicating with your device.

Open a browser and access the URL <http://0.0.0.0:5000>.

# First steps #

## Creating an agent ##

On the <http://0.0.0.0:5000/projects> page, enter the name "fml_agent" the field "agent name", then click on "create agent". Your new agent will appear in the table on this page.

Congratulations! You have created your first agent. Of course, it doesn't do anything yet.

What has happened when you clicked the "create agent" button? Navigate to the VM root folder on your hard drive. It contains a `ruby-workspace` folder. This `ruby-workspace` folder is your workspace (really?), you can symlink it if you want, but **you can not move it**. If you open this folder, you will see that the SDK has created a folder named `fml_agent` which contains your agent base structure.

Let's have a look at it.

## Agent structure ##

Here is the base agent structure:

```
    ruby_workspace
    `-- fml_agent
        |-- initial.rb
        |-- Gemfile
        |-- config/
        |   |-- protogen.json
        |   |-- scheduled.rb
        |   `-- fml_agent.yml
        |-- doc/
        |-- modules/
        `-- README.md

```

So, what are these files for?

- *initial.rb* is where the callbacks that allow communicating with the device are defined. Consider it the entry point of your agent. You can not rename this file nor move it.
- *Gemfile* is a standard... gemfile where you put the ruby gems you want to use with your agent.
- *protogen.json* is where you define the communication protocol between your devices and the server.
- *scheduled.rb* is where you define some tasks to be executed on a regular basis.
- *my_agent.yml* is an example configuration file.
- *doc* contains generated docs for your agent (notably generated Protogen documentation).
- *modules* is where you put your additional modules.
- *README.md* is a place where you can put information about your agent, because documentation is mandatory, isn't it?

## Configuring your agent ##

Open the `config/fml_agent.yml` file with your favorite text editor. This file is where you put configuration values for your agent.

This file uses YAML (a rather user-friendly explanation of YAML can be found [on Wikipedia](http://en.wikipedia.org/wiki/YAML)).

It currently contains four configuration values that are very important:

* `dynamic_channel_str` is the name of the channel(s) your agent is listening on (it can be a string or an array of strings). By convention, your agent will send its messages on the first configured channel.
Each message exchanged between a device and a server belongs to a given channel. An agent only reads messages on the channels which are configured in this config file.
* `suscribe_presence` is a boolean indicating whether your agent is listening to presences. A presence is an event send by the device indicating that the device is now connected, reconnected or disconnected.
* `suscribe_message` indicates if your agent listen to messages (a message is a general purpose way of exchanging data between a device and a server). As discussed above, your agent will only receive messages that are sent on a channel it is listening to.
* `suscribe_track` indicates if your agent listen to tracking data.

Out agent only needs to listen to messages, but for the sake of the example we will also listen to presences. So our `fml_agent.yml.yml` will look like:

```
default: &DEFAULT
  dynamic_channel_str: com.mdi.services.fml_agent
  subscribe_presence: true
  subscribe_message: true
  subscribe_track: false

development: *DEFAULT
```

Note: if you want to listen on several channel, the syntax looks like: `dynamic_channel_str: [com.mdi.services.fml_agent_channel_1, com.mdi.services.fml_agent_channel_2]` (with this configuration, your agent will send its messages on `com.mdi.services.fml_agent_channel_1`).

## Let's actually write some code ##

### A look at `initial.rb` ###

As said above, the entry point of your agent is the `initial.rb` file. Open this file in a text editor.

The default template looks like this:

```ruby
module Initial_agent_fml_agent

  include Sdk_api_fml_agent
  include Protogen_fml_agent if defined? Protogen_fml_agent

  def new_presence_from_device(presence)
    # Write your code here
  end

  def new_msg_from_device(msg)
    # Write your code here
  end

  def new_track_from_device(track)
    # Write your code here
  end

  def new_order(order)
    # Write your code here
  end

  #################################################
  # Implement below callbacks defined in Protogen #

end
```

It defines four callbacks called for specific events:

* `new_presence_from_device` is called each time a device is connected or disconnected. `presence` is an object of the class {CloudConnectServices::Presence CCS::Presence} holding the data related to this event.
* `new_msg_from_device` is called each time an incoming message from the device is received on one of your agent channels. `msg` is an object of the class {CloudConnectServices::Message CCS::Message}.
* `new_track_from_device` is called each time track data from the device is received. `track` is an object of the class {CloudConnectServices::Track CCS::Track}.
* `new_order` is called each time a scheduled order is about to happen. `order` is an object of the class {CloudConnectServices::Order CCS::Order}.

### Basic callbacks ###

For demonstration purposes, we are going to do two things:

* log each received presence
* if we receive a message whose content is "ping", we'll answer "pong"

(we'll do the real implementation of our agent a bit later when you are more familiar with the SDK)

#### Log each received presence ####

To write in logs, you don't have to roll on your own log system. Instead, you must use the {Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME::SDK::API.log SDK.API.log} method.

`SDK.API` is a Ruby module containing already configured helpers for your agent. You should use these instead of your own solutions. The SDK is an open environment, but if you use one of your own solutions rather than one provided by the SDK, your agent will need to be validated by MDI before being accepted.

Our `new_presence_from_device` callback becomes:

```ruby
def new_presence_from_device(presence)
  SDK.API.log.info("Received a presence! Asset #{presence.asset}: #{presence.type}")
end
```

Renember to read the documentation for each class if you need more information about a specific object. The main page for the SDK documentation is [here](http://0.0.0.0:5000/doc). From this main page you can access documentation on any topic. For instance, documentation on presences is {CloudConnectServices::Presence here: Presence}.

#### Answer "pong" ####

To answer to messages, the {Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME::SDK::DeviceGate SDK.API::device_gate} object is your friend.

```ruby
def new_msg_from_device(msg)
  if msg.content == "ping"
    SDK.API.device_gate.reply(msg, "pong")
  end
end
```

The {Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME::SDK::DeviceGate#reply SDK.DeviceGate#reply} method takes two parameters:

* the message to answer to
* the content of the response: a String, or a Protogen object (more on Protogen later).

As always, check the documentation about {CloudConnectServices::Presence Messages} and about the {Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME::SDK::DeviceGate SDK::DeviceGate} if you need a complete reference about these objects.

Note that you could also "push" the message to the device, but by doing so your new message would not be considered as a reply:

```ruby
# Just for reference
# Do not use this code for our example, it will not pass the tests
def new_msg_from_device(msg)
  if msg.content == "ping"
    SDK.API.gate.push(msg.asset, msg.account, "pong")
  end
end
```

## Start your agent ##

Time to have some action. Go to the ["SDK Agents"](http://0.0.0.0:5000) tab in your browser. Click on the red "Unmounted" button in front of your agent name. The button now displays "Mounted" which means that your agent is marked to be used next time the SDK agents server is restarted.

Now reboot the agents server by clicking the blue button on the top-right corner.

## Check the logs ##

To be sure the SDK agents server correctly started, go to the ["Server Log"](http://0.0.0.0:5000/logSdkAgentsPunk#endlog) tab.

The left column is a summary of what happened. Clicking on an item will display the corresponding detailed logs.

You should see a "ready to use!" item in the left column (and no red item) if everything went OK. If not, use the logs to fix the problems.

Should you ever need to access the raw logs generated by the SDK, you can find them in `ruby_workspace/sdk_logs`.

## Test your agent ##

To make sure our agent is working as intended, we could now write the corresponding device software component, connect a device to our PC, configure the device, upload the component on the device, and do some manual tests.

As this is a bit cumbersome, we'll rather simulate incoming messages from the device directly in Ruby code.

Create a folder named `tests` in your agent root directory. This folder (whose name is defined by convention i.e *you can not change this name*) contains tests files. A test file is a file whose name ends by `_spec.rb`. You can also have non-test files in this folder, and you can also have nested subfolders to keep your tests organized.

In this folder, create a `fml_messages_spec.rb` file. Your file structure should be:

```
   ruby_workspace
    `-- fml_agent
        |-- initial.rb
        |-- tests
        |   `-- fml_messages_spec.rb
        `-- (other stuff...)

```

The test file uses [Rspec](http://rubydoc.info/gems/rspec-core/frames) (a Ruby testing framework) and the result of the tests are displayed directly in the SDK GUI.
You don't need to know how to use Rspec to follow this tutorial.

Update your new file with this content:

```
require 'rspec'
require 'tests_helper' # used for simulating messages and waiting for server responses

describe "FML agent communication" do

  it "should say 'pong' to 'ping'" do
    # Create a new simulated message with content "ping" that will be sent on the channel "com.mdi.services.fml_agent"
    msg = TestsHelper::MessageFromDevice.new("ping", "com.mdi.services.fml_agent")

    # "send" this simulated message to the server
    msg.send_to_server

    # Wait 2 seconds for all server responses to our message (return after 10 responses to our message or after 2 seconds)
    responses = TestsHelper::wait_for_responses(msg, 10, 2)

    # Assertions
    # One and only one one response to our ping
    responses.should have(1).message
    # The content of the response is "pong"
    responses.first.content.should == "pong"

  end

end
```

I will not repeat once again that you should consult the docs for each class if you need more details :-)

Now let's run the tests. Reboot the agents server, then go to the [Unit tests](http://0.0.0.0:5000/unit_tests) page on the SDK GUI. On this page, there is a blue "Run tests" button that is waiting to be clicked, so click it (once the agents server is restarted, which could take a couple seconds).

Your test should pass. If not, the page will display information about the failure, and the logs should help you to track the error.


## Understanding the logs ##

Now is a good time to understand the complete sequence of events following the reception of a new message by the server.

Reboot the agents server (to clear the logs and start in a clean state), then run our single test. The log tab should display something like the following:

![Screenshot of the logs after a messsage has been sent to the server](/img/message_reception.png "Screenshot of the logs after a messsage has been sent to the server").

How to interpret this?

* at 11:36:50, our agents server is "ready to use". Previous events were related to setting up the server. You should understand the "suscribe presence" and "suscribe message": that is what we asked for in our configuration file. We'll talk about the other events later.
* at 11:37:16, the server received a new message; the ID of this message ends with 3600.
* Then it pushed an ACK to the device (this is a small message that says to the device "I received your message, I'm processing it").
* The incoming message was sent on a channel that our agent is listening to, so the next item indicates that the server forwarded the message to our agent. But you may be wondering: *Why did the ID of the message change?* In fact, the ID generated by the device (here, 3600), is a temporary ID. The server generated a new ID for this message. The mapping between the temporary ID and the server ID was sent in the ACK (you can see it if you click on the item corresponding to the ACK and read the fields tmpID and msgID of the ACK).
* Then the code of our agent sends a reply to this message (with the ID 9808).
* Eventually, the blue item indicates that the callback for our agent is finished and suceeded (it would be red if an error occured).

# Diving in #

Now that you know the basics, we can begin working on our agent. Before we start coding, let's take a moment to think about how we will implement the requirements.

We'll need to schedule a task to fetch the latests FML facts from the website. We'll have a class called `FmlCache` who will be responsible for updating the cache (ie fecthing data from the FML website) and giving access to the data in the cache.

We also need to define a protocol for exchanging messages between the device and the server: we need to describe what are the messages exchanged between the device and the server and what is the sequence of events caused by the reception of one message.

Defining and implementing this protocol ourselves may prove error-prone. Fortunately, you don't have to. Enter Protogen.

## Protogen, the MDI protocol generator ##

Protogen is a "protocol generator": you give it a file describing your protocol, and it generates the server and client code that implements this protocol. Then you simply manipulate Protogen objects in your code instead of messages. Here are the things you *don't* have to worry about if you use Protogen:

* splitting a large message in small messages so it is not rejected by the cloud (and reassembling the parts on the receiver side)
* writing serialization and deserialization code (deserialization here is is converting the message content into Ruby or Java objects)
* making sure that your communication code is correctly following your spec
* writing boilerplate code to dispatch messages to the appropriate receivers
* writing your own cookies system

Because I am lazy and I don't want to explain here how to correctly do these things, we'll use Protogen in this project.

(side note: Protogen usage is of course not mandatory for your projects, but will greatly simplify your code)

### The protocol file ###

The protocol file is the `protogen.json` file located in the `config` folder of your agent. The minimal template for this file is:

```javascript
    {
      "protocol_version": 1,

      "messages": {

      },

      "cookies": {

      }
    }
```

As the filename indicates, this file follows the [JSON](http://en.wikipedia.org/wiki/JSON) format. It defines messages and cookies.

Let's start to configure a new message:

```javascript
    {
      "protocol_version": 1,

      "messages": {

        "FmlList": {
            "_description": "A list of FML facts",
            "_way": "toDevice",
            "_device_callback": "fmlListCallback",
          }

      },

      "cookies": {

      }
    }
```

We added a new object to our protocol: a `FmlList`. The name of a Protogen object *must* start with an uppercase letter.

We also added three configuration fields to our object. A configuration field begins with an underscore followed by a lowercase letter and is used to attach configuration data to our object. Here we defined:

* `"_description": "..."`: a documentation string to help people understand your protocol.
* `"_way": "toDevice"`: this object will be sent from the server to the device.
* `"_server_callback": "fmlListCallback"` because we said this object will be received by the device, we need to tell Protogen which method to call when this object is received.

Let's update this object (so it actually carries valuable information) by adding fields.

```javascript
    {
      "protocol_version": 1,

      "messages": {

        "FmlList": {
            "_description": "A list of FML facts",
            "_way": "toDevice",
            "_device_callback": "fmlListCallback",
            "facts": {"type": "FmlFact", "modifier":"required", "array":true, "docstring":"A list aof FML."},
            "last_cache_update": {"type": "string", "modifier":"required", "docstring":"The date the server cache was updated for the last time."}
          },

      },

      "cookies": {

      }
    }
```

A field must begin with an lowercase letter. You have to define its type (could be a base type like "int" or "string" or another Protogen object) and tell if its required or optional. You should also add a docstring.

You can indicate a field is an array by adding `"array": true` (note the absence of quotes around `true`) as in our example.

Let's finish to write this file. Its contents should be easy enough to understand now. Note that:

* the `_way` field of the `FmlFact` is set to "none", because we don't want this message to be sent by itself (it must be sent in a `FmlList`). That's also why there is no device callback for this object.
* we define the `FmlFact` object before the `FmlList` because the `FmlList` includes this object in its definition.

```javascript
    {
      "protocol_version": 1,

      "messages": {

        "FmlFact": {
          "_description": "A single FML fact",
          "_way":"none",
          "content": {"type":"string", "modifier":"required", "docstring":"The text of this FML."},
          "language": {"type":"string", "modifier":"optional","docstring":"Default to English (only supported language for now)"}
        },

        "FmlList": {
          "_description": "A list of FML facts",
          "_way": "toDevice",
          "_device_callback": "fmlListCallback",
          "facts": {"type": "FmlFact", "modifier":"required", "array":true, "docstring":"A list aof FML."},
          "last_cache_update": {"type": "string", "modifier":"required", "docstring":"The date the server cache was updated for the last time."}
        },

        "FmlRequest": {
          "_description": "Sent when the device wants to fecth some FML.",
          "_way": "toServer",
          "_server_callback": "fml_request_callback",
          "number":{"type":"string", "modifier":"optional", "docstring":"the number of wanted FML (default to 3)."},
          "preferred_language": {"type":"string", "modifier":"optional","docstring":"the server should try to return FML in this language (not supported for now)"}
        }

      },

      "cookies": {

      }
    }
```

We won't talk about cookies here. The complete Protogen reference (agent-side) can be found in the {file:guides/protogen.md Protogen guide}.

Save this protocol to the `fml_agent/config/protocol.json` file.

### Verifying that our protocol is correct ###

Reboot the agents server. Check in the logs that you have a green "Generating Protogen for agent fml\_agent" item.

If you have a red item, you probably made an error in your protocol file. See the detailed logs by clicking on this red item to see where things went wrong.

Yep, that's it, nothing more to do here, Protogen is ready to use.

### Writing tests for a Protogen protocol ###

#### First draft ####

Now, let's write some tests for our protocol. Yes, we don't have written yet the actual code that will handle the device requests.

However, writing tests at this stage will demonstrate how Protogen is used in your code. It will also make our goal more precise: when our agent will eventually pass these tests, we can consider our agent works (this is, of course, oversimplification).

Let's add to the `tests/fml_agent.yml` file some tests (explanations will follow):

```ruby
require 'rspec'
require 'tests_helper'

describe "FML agent communication" do

  it "should say 'pong' to 'ping'" do
    # snip... the same test as above
  end

  context "when using Protogen" do

    it "should correctly answers a FmlRequest" do
      # Create the Protogen object
      request = Protogen_fml_agent::Protogen::Messages::FmlRequest.new
      request.number = 4
      request.preferred_language = "english"

      # Create a simulated message with this object
      msg = TestsHelper::ProtogenFromDevice.new(request, "com.mdi.services.fml_agent")
      msg.send_to_server

      # Wait for responses
      responses = TestsHelper::wait_for_responses(msg)

      # Assertions
      # Even if Protogen split up our message in several small messages,
      # the SDK will automagically detect these messages as one response
      responses.should have(1).item
      fml_list = responses.first
      fml_list.class.should == Protogen_fml_agent::Protogen::Messages::FmlList
      fml_list.facts.should have(4).items
      fml_list.facts.each do |fact|
        fact.content.should_not be_empty
      end

    end

  end

end
```

All your Protogen messages belongs to the namespace `Protogen_fml_agent::Protogen::Messages`. You can manipulate them as standard Ruby classes as demonstrated in this example. The namespace `Protogen_fml_agent` is generated by Protogen and its name will obviously change depending on the name of your agent.

In the above code, we also use {TestsHelper::ProtogenFromDevice} to simulate a Protogen message coming from a device.

#### Clean the code ####

To save a few keystrokes, we can use RSpec `shared_context` to alias `Protogen` to `Protogen_fml_agent::Protogen`, like this:


```ruby
require 'rspec'
require 'tests_helper'

# define a shared context
shared_context "protogen_for_fml" do
  Protogen = Protogen_fml_agent::Protogen
end

describe "FML agent communication" do

  it "should say 'pong' to 'ping'" do
    # snip... the same test as above
  end

  context "when using Protogen" do

    # use the defined shared_context in all our tests
    include_context "protogen_for_fml"

    it "should correctly answers a FmlRequest" do
      # Create the Protogen object
      request = Protogen::Messages::FmlRequest.new # note that we don't have to specify the full namespace
      request.number = 4
      request.preferred_language = "english"

      # Create a simulated message with this object
      msg = TestsHelper::ProtogenFromDevice.new(request, "com.mdi.services.fml_agent")
      msg.send_to_server

      # Wait for responses
      responses = TestsHelper::wait_for_responses(msg)

      # Assertions
      # Even if Protogen split up our message in several small messages,
      # the SDK is clever enough to detect these messages as one response
      responses.should have(1).item
      fml_list = responses.first.content
      fml_list.class.should == Protogen::Messages::FmlList
      fml_list.facts.should have(4).items
      fml_list.facts.each do |fact|
        fact.content.should_not be_empty
      end

    end

  end

end
```

If you run the tests, this latest test should fail. Let's work on making this test green.

## The `Cache` class ##

The `modules` subfolder in your agent root directory is the place where you are supposed to put your Ruby code, so you can keep the `initial.rb` file slim and sleek.

Create the `modules/cache.rb` file. This file will contain our cache definition. The cache will need to return a given number of random FMLs from the latest FMLs on the website. As discussed in the introduction, we will not query the website each time we ask the cache for FMLs. Instead, the cache will decide if it needs to be updated (and will update itself), and if it can use the FMLs it retrieved from a previous request, because this data is not too old yet.

To implement this, our agent has access to a [Redis database](http://redis.io/). Redis is a simple key-value database that lives in RAM. The Redis API is documented [here](http://redis.io/commands); you should at least be aware of the commands `get` (to set a key-value pair in the database), `set` (to retrieve the value associated to a key) and `expire`.

The SDK gives you an already configured Redis object: {Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME::SDK::API.redis SDK.API.redis}. We'll use it in our cache implementation.

### Code stub ###

Our cache will be an instance of `FmlCache` defined in a module name `Cache` (for proper namespacing).
I also define an `UpdateFailed` error by subclassing the ruby `StandardError` exception. We will raise this error if something goes wrong when we try to update the cache.

```ruby
module Cache

  class UpdateFailed < StandardError
  end

  class FmlCache
  end

end
```

### Constructor ###

Let's add a constructor for our class. This constructor simply takes an URL and a validity period, and connect to our agent Redis instance.

```ruby
module Cache

  class UpdateFailed < StandardError
  end

  class FmlCache

    include Sdk_api_fml_agent

    # Instanciates a new cache. Several instances share the same internal Redis cache (and thus share data).
    # @param [String] url the complete URL the cache will connect to to update itself
    # @param [Fixnum] validity_period in hours, duration after which the updated values will be invalidated
    # @note the validity period will only affect cache elements that are created/modified by this instance after this instance was created
    def initialize(url = "http://www.fmylife.com", validity_period = 48)
      @uri = URI(url)
      @validity_period = validity_period
      @redis = SDK.API.redis
    end

  end

end
```

The line `include Sdk_api_fml_agent` asks for an explanation. The `SDK.API` namespace is in fact contained in the `Sdk_api_fml_agent` module (the name of this module depends on our agent name). If you don't include this module in your class, you have to write something like:

```
@redis = Sdk_api_fml_agent::SDK.API.redis
```

But because I don't want to type this namespace everytime I need to access the `SDK.API` object, I just include it in every class that need it.

When we write the `initial.rb` file we didn't worry about that. That is because the default code for `initial.rb` already contains the line `include Sdk_api_fml_agent` (take a look at it if you aren't sure).

If the above explanations are gibberish for you, just remember to add `include Sdk_api_fml_agent` in each class or module that needs `SDK.API` and things should Just Work.

### Fetch the HTML data from FML ###

To query an external API, you can use the [standard Ruby library `net/http`](http://ruby-doc.org/stdlib-2.0.0/libdoc/net/http/rdoc/Net/HTTP.html).

**Note that I check the return code before continuing**, as anything other than 200 (in our case) is an error. It is important not to assume that a call to an external API will succeed. Caveat: the response code is actually a String, not an integer.

Also note that I raise an exception if I can't fetch the data. *You don't need to worry about catching this exception* because there is nothing you can do to solve this problem. Such unaught exceptions will trigger an alert and abort the processing of the
current message.

```ruby
require 'net/http'
 # snip ...

 class FmlCache

    # snip ...

    # @return the response body of FML main page, as HTML
    # @raise UpdateFailed
    def get_response_body
      response = Net::HTTP.get_response(@uri)
      # check if the query went OK
      if response.code != "200" # 200 is HTTP OK code
        raise UpdateFailed.new("Error when trying to contact #{url} to update the cache. Status was #{response.code} #{response.message}")
      end
      response.body
    end
  end
```

(Side note: in this example, we could decide not to raise an exception but just log the failure and use an outdated cache. It is the responsibility of the agent designer to decide how to handle such cases. However, *do not silently ignore errors*, at least use {Sdk_api_XX_DOWNCASED_CLEAN_PROJECT_NAME::SDK::API.log SDK.API.log} to log the failure (`SDK.API.log.error`))


### Parse and store the data in Redis ###

Now that we have a method that can retrieve HTML data from FML, we need to parse it. You don't need to understand the code related to parsing this data (which uses the Nokogiri gem, already included with the SDK so you don't have to add it to your Gemfile).

However, focus on how I use Redis to store the parsed data.

```ruby
require 'net/http'
require 'nokogiri'
# ... snip

class FmlCache

    # snip ...

    # Update the cache data by retrieving all the FMLs on the first page.
    # @raise UpdateFailed
    def update
      fmls = parse_html(get_response_body)

      @redis.set "last_update", Time.now.to_i
      @redis.set "max_index", fmls.size - 1
      @redis.expire "max_index", (@validity_period * 60 * 60).to_i

      # We assume we get the same number of FMLs with each request
      fmls.each_with_index do |fml, i|
        @redis.set i, fml
        @redis.expire i, (@validity_period * 60 * 60).to_i
      end
    end

    # @param [String] html_data HTML from the main page of the FML website
    # @return [Array<String>] an array of FMLs
    def parse_html(html_data)
      # We use the Nokogiri gem to read and parse the HTML from the page.
      # In a "real" application, we'd ask for access to the website developers API
      # so we could get data in a more developer-friendly format
      # see http://nokogiri.org/ for information
      doc = Nokogiri::HTML(html_data) do |config|
        # Disable network connections during parsing and remove blank nodes
        config.noblanks.nonet
      end
      # By inspecting the DOM of the main page of fmylife.com, I come up with this
      # CSS selection rule to retrieve the text of the FMLs
      doc.css(".wrapper .post > p").map do |node|
        node.text
      end
    end

end
```

### The complete implementation ###

Let's add a few convenience methods to our class, and we are good to go!

```ruby
require 'net/http'
require 'nokogiri'

module Cache

  class UpdateFailed < StandardError
  end

  class FmlCache

    include Sdk_api_fml_agent

    # Instanciates a new cache. Several instances share the same internal Redis cache (and thus share data).
    # @param [String] url the complete URL the cache will connect to to update itself
    # @param [Fixnum] validity_period in hours, duration after which the updated values will be invalidated
    # @note the validity period will only affect cache elements that are created/modified by this instance after this instance was created
    def initialize(url = "http://www.fmylife.com", validity_period = 48)
      @uri = URI(url)
      @validity_period = validity_period
      @redis = SDK.API.redis
    end

    # Update the cache data by retrieving all the FMLs on the first page.
    # @raise UpdateFailed
    def update

      fmls = parse_html(get_response_body)

      @redis.set "last_update", Time.now.to_i
      @redis.set "max_index", fmls.size - 1
      @redis.expire "max_index", (@validity_period * 60 * 60).to_i

      # We assume we get the same number of FMLs with each request
      fmls.each_with_index do |fml, i|
        @redis.set i, fml
        @redis.expire i, (@validity_period * 60 * 60).to_i
      end
    end

    # Get (unique) random FMLs from the cache.
    # @param [Fixnum] number the number of FML to retrieve
    # @note if number is greater than the currently stored number of FMLs, it
    #   will return some FLMs more than once
    # @raise UpdateFailed if accessing the cache needed updating data, but this update failed for some reason
    def get(number)
      # Generate random unique indexes
      if max_index.nil? # cache needs updating
        update
      end
      indexes = (0..max_index).to_a.sample(number)
      # get those indexes from redis
      indexes.map {|i| @redis.get i }
    end

    def empty
      return if max_index.nil? # keys already expired
      0.upto(max_index) do |i|
        @redis.del i
      end
    end

    # @return the current number of FMLs stored in the cache, or `nil` if the cache is empty
    def fmls_count
      max_index
    end

    # @return [Time] the last time this cache was updated (or `nil` if it never was updated)
    def last_update
      time = @redis.get("last_update")
      Time.at(time) unless time.nil?
    end

    private

    # @return the response body of FML main page, as HTML
    # @raise UpdateFailed
    def get_response_body
      response = Net::HTTP.get_response(@uri)
      # check if the query went OK
      if response.code != "200" # 200 is HTTP OK code
        raise UpdateFailed.new("Error when trying to contact #{url} to update the cache. Status was #{response.code} #{response.message}")
      end
      response.body
    end

    def max_index
      max_index = @redis.get "max_index"
      max_index.to_i unless max_index.nil?
    end

    # @param [String] html_data HTML from the main page of the FML website
    # @return [Array<String>] an array of FMLs
    def parse_html(html_data)
      # We use the Nokogiri gem to read and parse the HTML from the page.
      # In a "real" application, we'd ask for access to the website developers API
      # so we could get data in a more developer-friendly format
      # see http://nokogiri.org/ for information
      doc = Nokogiri::HTML(html_data) do |config|
        # Disable network connections during parsing and remove blank nodes
        config.noblanks.nonet
      end
      # By inspecting the DOM of the main page of fmylife.com, I come up with this
      # CSS selection rule to retrieve the text of the FMLs
      doc.css(".wrapper .post > p").map do |node|
        node.text
      end
    end

  end # class FmlCache

end # module cache
```

### Tests tests tests! ###

And because I am serious, I also wrote some basic tests for my cache so I get my back covered. Put this in a new file named `tests/cache_spec.rb`.

```ruby
require 'rspec'
require_relative '../modules/cache'

describe "FmlCache" do

  it "should successfully update itself" do
    cache = Cache::FmlCache.new
    cache.empty
    cache.update
    fmls = cache.get(3)
    fmls.should have(3).items
  end

  it "should delete expired keys" do
    cache = Cache::FmlCache.new("http://www.fmylife.com", 0.0001) # create a cache with a very short expiration date
    cache.update
    sleep(1)
    cache.fmls_count.should be(nil)
  end

  it "should return strings that end with 'FML'" do
    cache = Cache::FmlCache.new
    fml = cache.get(1).first
    fml.should end_with "FML"
  end

end
```

Tests are also useful to describe how to use your classes. In fact, you could even write your tests before you start coding your classes (so you describe their expected behaviour) and then do the actual coding.

You can run the tests (after having rebooted the server); these three tests should pass.

Later on this guide we will also configure a scheduled task so the cache will update itself on a regular basis, so we are sure there is up-to-date data in the cache.

## Putting things together: back to `initial.rb` ##

Now that we have our cache, we can answer to the device queries for FMLs.

Here is our complete `initial.rb`

```ruby
require_relative 'modules/cache'

module Initial_agent_fml_agent

  include Sdk_api_fml_agent
  include Protogen_fml_agent if defined? Protogen_fml_agent

  def new_presence_from_device(presence)
    SDK.API.log.info("Received a presence! Asset #{presence.asset}: #{presence.type}")
  end

  def new_msg_from_device(msg)
    if msg.content == "ping"
      SDK.API.device_gate.reply(msg, "pong")
    end
  end

  def new_track_from_device(track)
    # Write your code here
  end

  def new_order(order)
    # Write your code here
  end

  #################################################
  # Implement below callbacks defined in Protogen #

  # msg is a `CSS::Message` whose content is a Protogen object
  def fml_request_callback(msg)

    # Get the Protogen content of the message
    request = msg.content

    # Check how many FMLs the device want
    number_of_fmls = request.number

    # Get this many FMLs
    # Note that we don't care about the UpdateFailed exception that could be raised
    cache = Cache::FmlCache.new
    fmls = cache.get(number_of_fmls)

    # Build the response
    list = Protogen::Messages::FmlList.new
    list.facts = fmls.map do |fml|
      fact = Protogen::Messages::FmlFact.new
      fact.content = fml
      fact.language = "english"
      fact
    end
    list.last_cache_update = cache.last_update.to_s

    # And send it
    SDK.API.device_gate.reply(msg, list)
  end

end
```

Reboot the server and run the tests. They should all pass.

Congratulations! You just wrote your first agent for the MDI cloud!

# Scheduled orders #

To complete our agent we will force it to update its cache every day at 3 am.
Doing so is easy:

* Replace your `config/schedule.rb` with the following content:

```ruby
every 1.day, :at => '3:00 am' do
  execute_order "update_cache"
end
```

* Update your `initial.rb` `new_order` method:

```ruby
  def new_order(order)
    if order.code == "update_cache"
      cache = Cache::FmlCache.new.update
    else
      raise "Unknown order: #{order.to_hash.inspect}"
    end
  end
```

* Reboot the agents server. In your VM, the scheduled order will not be executed automatically (Anyway, I think you are not sitting in front of your computer at 3 am, coding your agent). To test it, click the `Perform: 'update_cache'` that appeared on the [SDK Agents](http://0.0.0.0:5000/projects) page.

* Check the logs, the scheduled order should have been executed successfully.

# Further reading #

The documentation includes other guides that cover some topics in more detail:

* the {file:guides/sdk_api.md SDK API} guide describes the most important API of the SDK (logs, Redis...)
* the {file:guides/guidelines.md guidelines} describes some rules your agent must follow
* the {file:guides/protogen.md Protogen guide} is the comprehensive reference for everything related to Protogen
* the {file:guides/tests.md tests guide} describes the testing framework of the SDK

You can build upon this example if you want further training. Interesting ideas for our agent may be:

* instead of solely the latests FMLs, fetch the latest FMLS plus random FMLs (to have more FMLs in the cache)
* add more languages (for instance, for French, use http://www.viedemerde.fr/)
* expand the protocol so the device can explicitly ask for data from a given website
* ...

# Device-side #

To be continued...